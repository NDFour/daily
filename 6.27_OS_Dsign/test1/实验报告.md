# 操作系统 -- 实验一实验报告

## 实验一：Windows进程管理

### 实验内容和步骤

1.  编写基本的Win32 Console Application
*实验代码：*
```c
#include "stdafx.h"
#include<iostream>
void main()
{
	std::cout<<"Hello,Win32 Consol Application"<<std::endl;
}
```
*运行截图*
![](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fsn4xdil4pj30iq04maav.jpg)

2. 创建进程
*实验代码：*
```c
// shiyan1_2.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include<windows.h>
#include<iostream>
#include<stdio.h>

// 创建传递过来的进程的克隆过程并赋予其ID值
void StartClone(int nCloneID)
{
	// 提取用于当前可执行文件的文件名
	// szFilename:[D:\testProject\Debug\testProject.exe]
	// MAX_PATH:[MAX_PATH是C语言运行时库中通过#define指令定义的一个宏常量，它定义了编译器所支持的最长全路径名的长度]
	// Windows的MAX_PATH:[MAX_PATH的解释： 文件名最长256（ANSI），加上盘符（X:\）3字节，259字节，再加上结束符1字节，共260]
	TCHAR szFilename[MAX_PATH];
	GetModuleFileName(NULL,szFilename,MAX_PATH);

	// 格式化用于子进程的命令行并通知其EXE文件名和克隆ID
	// szCmdLine:["D:\testProject\Debug\testProject.exe"5]
	TCHAR szCmdLine[MAX_PATH];
	sprintf(szCmdLine,"\"%s\"%d",szFilename,nCloneID);


	// 用于子进程的STARTUPINFO结构
	STARTUPINFO si;
	ZeroMemory(&si,sizeof(si));
	si.cb=sizeof(si); // 必须是本结构的大小

	// 返回的用于子进程的进程信息
	PROCESS_INFORMATION pi;

	// 利用同样的可执行文件和命令行创建进程，并赋予其子进程的性质
	BOOL bCreateOK=::CreateProcess(
		szFilename,  // 产生这个EXE文件的应用程序的名称
		szCmdLine,   // 告诉其行为像一个子进程的标志
		NULL,        // 缺省的进程安全性
		NULL,        // 缺省的线程安全性
		FALSE,       // 不继承句柄
		CREATE_NEW_CONSOLE, // 使用新的控制台
		NULL,        // 新的环境
		NULL,        // 当前目录
		&si,         // 启动信息
		&pi);        // 返回的进程信息

	// 对子进程释放引用
	if(bCreateOK)
	{
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
	}
}

int main(int argc, char* argv[])
{
	// 确定派生出几个进程，及派生进程在进程列表中的位置
	int nClone=0;
	// 修改语句: int nClone;
	// 第一次修改： nClone=0;
	if(argc>1)
	{
		// 从第二个参数中提取克隆 ID
		// 之所以按照注释修改代码就会死循环，原因在于父进程在创建子进程时会把nClone当作命令行参数传入子进程，nClone=0的位置就显得尤为重要!!（参考line 20注释，命令行后附带参数[cClone]）
		::sscanf(argv[1],"%d",&nClone);
		printf("子进程读取到命令行参数:%d\n",nClone);
	}
	// 第二次修改： nClone=0;
	//nClone=0;
	// 显示进程位置
	std::cout<<"Process ID:"<<::GetCurrentProcessId()
		<<",Clone　ID:"<<nClone
		<<std::endl;

	// 检查是否有创建子进程的需要
	const int c_nCloneMax=5;
	if(nClone<c_nCloneMax)
	{
		// 发送新进程的命令行和克隆号
		StartClone(++nClone);
	}
	// 等待响应键盘输入结束进程
	getchar();
	return 0;
}

```
*进程相关的行为属性截图（任务管理器）*
![](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fsn6ceywv7j30t30mgjyx.jpg)

3. 父进程的简单通信及终止进程
**实验代码：**
```c
/*
 * shiyan1_3.cpp : Defines the entry point for the console application.
 *
 * procterm 项目
 */

#include "stdafx.h"
#include<windows.h>
#include<iostream>
#include<stdio.h>
static LPCTSTR g_szMutexName="w2kdg.ProcTerm.mutex.Suicide";

// 创建当前进程的克隆进程的简单方法
void StartClone()
{
	// 提取当前可执行文件的文件名
	TCHAR szFilename[MAX_PATH];
	GetModuleFileName(NULL,szFilename,MAX_PATH);

	// 格式化用于子进程的命令行，字符串”child“将作为形参传递给子进程的main函数
	TCHAR szCmdLine[MAX_PATH];
	//// 实验1-3 步骤3：将下句中的字符创child改为别的字符创，重新编译执行，执行前请先保存已经完成的工作
	sprintf(szCmdLine,"\"%s\"child",szFilename);

	// 子进程的启动信息结构
	STARTUPINFO si;
	ZeroMemory(&si,sizeof(si));
	si.cb=sizeof(si);  // 应当是此结构的大小

	// 返回的用于子进程的进程信息
	PROCESS_INFORMATION pi;

	// 用同样的可执行文件名和命令行创建进程，并指明他是一个子进程
	BOOL bCreateOK=CreateProcess(
		szFilename, // 产生的应用程序的名称（本exe文件）
		szCmdLine,  // 告诉我们这是一个子进程的标志
		NULL, // 用于线程的缺省的安全性
		NULL, // 用于线程的缺省安全性
		FALSE,  // 不继承句柄
		CREATE_NEW_CONSOLE, // 创建新窗口
		NULL, // 新环境
		NULL, // 当前目录
		&si, // 启动信息结构
		&pi); // 启动的进程信息

	// 释放指向子进程的引用
	if(bCreateOK)
	{
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
	}
}

void Parent()
{
	// 创建”自杀“互斥程序体
	HANDLE hMutexSuicide=CreateMutex(
		NULL, // 缺省的安全性
		TRUE, // 最初拥有的
		g_szMutexName); // 互斥体名称
	if(hMutexSuicide!=NULL)
	{
		// 创建子进程
		std::cout<<"Creating the child process."<<std::endl;
		StartClone();
		// 指令子进程”杀“掉自身
		std::cout<<"Telling the child process to quit."<<std::endl;
		// 等待父进程的键盘响应
		getchar();
		// 释放互斥体的所有权，这个信号会送给子进程的WaitForSingleObject过程
		ReleaseMutex(hMutexSuicide);
		// 消除句柄
		CloseHandle(hMutexSuicide);
	}
}

void Child()
{
	// 打开”自杀“互斥体
	HANDLE hMutexSuicide=OpenMutex(
		SYNCHRONIZE, // 打开用于同步
		FALSE, // 不需要向下传递
		g_szMutexName); // 名称
	if(hMutexSuicide!=NULL)
	{
		// 报告我们正在等待指令
		std::cout<<"Child waiting for suicide instructions."<<std::endl;

		// 子进程进入阻塞状态，等待父进程通过互斥体发来的信号
		WaitForSingleObject(hMutexSuicide,INFINITE);
		// 实验1-3步骤4：将上句改为 WaitForSingleObject(hMutexSuicide,0),重新百衲衣执行
		
		// 准备好终止，清除句柄
		std::cout<<"Child quiting."<<std::endl;
		CloseHandle(hMutexSuicide);
	}
}

int main(int argc,char* argv[])
{
	// 决定其行为是父进程还是子进程
	if(argc>1 && ::strcmp(argv[1],"child")==0)
	{
		Child();
	}
	else
	{
		Parent();
	}
	return 0;
}
```
**实验截图（程序运行截图）：**
![实验1-3 父子进程的简单通信及终止进程截图](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fsn77vs0c7j30zj0sfwj9.jpg)
